При передаче информации в протоколе используются следующие типы данных:
1. Координаты ячейки === Coords = (Int, Int)
- это пара чисел -- координаты ячейки на поле игры. Ось X направлена слева направо, Y сверху вниз. 
То есть начало координат в верхнем левом углу
Например, если n = 16 и поле n*n, то координаты могут выглядеть так: (0,0); (15,2); (4,3)

2. Направление === Direction = UP | DOWN | LEFT | RIGHT | HERE
- означает направление движения nyan-cat / охотника от текущей позиции. Направление может принимать пять различных значений

3. TELEPORT
- сообщение, которое передаёт front-end охотника, своему back-end, чтобы указать, что он хочет воспользоваться телепортом в текущей ячейке.

============ Протокол ============
I Судья

1. back-end
1) При инициализации ждёт от front-end координаты ячейки, в которой судья захочет поместить nyan-cat
2) Отправляет multi-cast для каждой ячейки поля:
* в какой стороне от неё находится nyan-cat
* флаг - надо ли отправить охотнику в ответ его место положение (зависит от расстояния до клетки)
* если на ячейке есть телепорт, то координаты того, куда ведёт телепорт

Принимает сообщения с местоположением охотников в радиусе видимости. Передаём эту информацию на front-end в примерно таком виде:
{
    hunter_coords_1
    hunter_coords_2
    ...
    hunter_coords_l
}
, где
hunter_coords_i :: Coords (имеют тип)

2. front-end
1) При иницилизации определяет на какой позиции будет стоять nyan-cat и отправляет эту информацию (координаты) на back-end
2) Принимает инфу от back-end.
Отправляет обратно на back-end направление куда сместился nyan-cat и, возможно, откуда и куда появился телепорт. Что-то типа:
{
    nyan_cat_direction,
    from_teleport_coords_1, to_teleport_coords_1
    from_teleport_coords_2, to_teleport_coords_2
    ...    
    from_teleport_coords_m, to_teleport_coords_m
}
, где 
nyan_cat_direction     :: Direction
from_teleport_coords_i :: Coords
to_teleport_coords_i   :: Coords


II Охотник

1. back-end:
1) При инициализации рандомно генерирует начальную позицию и отсылает её на front-end.
2) Далее, подписывается на опредёлённое количество ячеек (положение охотника + клетки тени) и получает на них multi-cast сообщение с информацией о направлении nyan-cat и расстоянием до nyan-cat. Если охотник находится в радиусе чутья nyan-cat (стоит флаг), отправляет ответное сообщение. Далее обрабатывает направления: переводит эту информацию в примерно такой вид:
{
    from_hunter_direction, out_teleport_coords
    shadow_coords_1: direction_1
    ...
    shadow_coords_k: direction_k
}
, где
shadow_coords_i 	  :: Coords
out_teleport_coords   :: Coords
from_hunter_direction :: Direction
direction_i 		  :: Direction

, причём
shadow_coords_i - координаты i-й тени охотника
out_teleport_coords - координаты выходного телепорта, если на месте охотника есть телепорт
from_hunter_direction - направление от охотника, до nyan-cat
direction_i  - направления от i-й тени до nyan-cat

Пример:
{
    DOWN, (10,7)
    (6,5): LEFT
}

3) Ждёт сообщение об изменении положения охотника от front-end. Соответственно с направлением движения охотника меняем адрес подписки на multicast. Если направление HERE и оно было сделано k раз подряд, то считаем что получили силу тени и добавили пожизненную подписку на текущую клетку.

2. front-end:
1) Ждёт сообщение о начальной позиции охотника. Далее ждёт первого сообщения о положении nyan-cat.
2) Принимает инфу от back-end. Передаёт обратно направление куда он хочет сдвинуться или TELEPORT, если он хочет воспользоваться телепортом.
